---
title: CSCB324 Състезателно програмиране - I част
enableToc: true
tags: 
- fundamentals
- programming
---  
> [!info]  
>   
> Записки от лекциите по ["CSCB324 Състезателно програмиране - I част"](https://ecatalog.nbu.bg/default.asp?V_Year=2018&YSem=3&Spec_ID=&Mod_ID=&PageShow=coursepresent&P_Menu=courses_part1&Fac_ID=3&M_PHD=&P_ID=832&TabIndex=&K_ID=48830&K_TypeID=26&l=0), водени от доц. Николай Киров, д-р.  

## Лекция №1

### Вход и изход за много примери

```cpp
// Четене на зададен брой примери (числа)  
int n;  
cin >> n;  
for (int i = 0; i < n; i++) { cin >> ... }  

// Четене до края на файла за числа или думи (низове)
while (cin >> x) { ...}  
while (cin >> x && x > 0) { ... }   
  
// Четене до края на файла на редове (низове)  
string st;  
while(getline(cin, st)) { ... }
```

> [!tip]
> Може да ползваме `string` за обработка вход като "Дадени са две цели числа в интервала $[-10^{100}, 10^{100}]$".


### Структури от данни - STL

#### Въведение в STL

**Контейнери:**
- съдържат информацията, която обработваме
- биват два типа:
	- контейнери-редици (sequence): елементите са съхранени последователно (пр. `vector`, `deque`, `list`, `forward_list`)
	- асоциативни: елементите са съхранени под формата на двойки: ключ стойност (пр. `map/unordered_map`, `multimap/unorederd_multipmap`, `set/unordered_set`, `multiset/unordered_multiset`)

**Итератори:**
- дават достъп до информацията, която контейнера съдържа

**Алгоритми:**
- използвайки итераторите, работят с информацията съдържана в контейнерите: `sort`, `reverse` и др.

#### Контейнер-редици

##### Вектор `std::vector`

**Подходящ:**
- добавяне на елементи, но не и премахване
- бързо търсене по индекс
- конветртиране до `C-style` масив

**Неподходящ:**
- добавяне/изтриване на елементи в средата на списъка
- търсене на елемент по индекс, който не е число

**Сложност:**
- $O(n)$: вмъкване в началото, вмъкване на позиция, премахване на начален елемент, премахване на елемент на позиция, търсене на елемент по стойност
- $O(1)$: добавяне на елемент в края, премахване на елемент в края, достъпване на елемент на позиция

##### Дек `std::deque`

Същите характеристики като `std::vector`, но с ефективни начини за добавяне/премахване на елементи в началото.

**Сложност:**
- $O(n)$: вмъкване на елемент на позиция, премахване на елемент на позиция, търсене на елемент по стойност
- $O(1)$: вмъкване на елемент в началото, вмъкване на елемент в края, премахване на елемент в началото, премахване на елемент в края, достъпване на елемент на позиция


##### Списък `std::list/std::forward_list`

**Предимства:**
- добавяне на елементи в средата/началото на списъка
- ефикасно сортиране (смяна на pointer вместо копиране)

**Недостатъци:**
- директен достъп до елементи

> Ако имаме нужда от двупосочно итериране, да се ползва `std::list`, ако нямаме - `std::forward_list`.

**Сложност:**
- $O(n)$: вмъкване на елемент на позиция, премахване на елемент на позиция, достъпване на елемент на позиция, търсене на елемент по стойност
- $O(1)$: вмъкване на елемент в началото, вмъкване на елемент в края, премахване на елемент в началото, премахване на елемент в края


> Contiguous memory is when the memory is in one big block without any gaps.



#### Асоциативни контейнери

##### `std::map` / `std::unordered_map`

**Подходящ:**
- съхранение на двойки ключ/стойност
- търсене по ключ (константно време)
- проверка дали съществува двойка ключ/стойност
- премахване на повторения
- `std::map` - подреден map / `std::unordered_map` - хеш таблица

**Неподходящ:**
- сортиране

> `std::unordered_map` е по-бързо от `std::map`. Използват се за `binary search trees`.

**Сложност:**

| Действие | `std::map` | `std::unordered_map`|
|-------|:--------:|:--------:|
| Вмъкване | $O(log(n))$ | O(1)|
| Достъп по ключ | $O(log(n))$ | O(1)|
| Премахване по ключ | $O(log(n))$ | O(1)|
| Търсене по стойност | $O(log(n))$ | - |
| Премахване по стойност | $O(log(n))$ | - |

##### `std::set`

**Подходящ:**
- премахване на повторения
- подреден динамичен списък

**Неподходящ:**
- директен достъп по индекс

> Използват се за `binary search trees`.

**Сложност:** 
- $O(log(n))$: добавяне / премахване / търсене

##### `std::stack`

**Подходящ:**
- "First-in Last-Out" действия
- обръщане на реда на елементи

**Сложност:**
- $O(1)$: вмъкване в края, премахване от края, достъпване на последния елемент

##### `std::queue`

**Подходящ:**
- "First-in First-out" действия

**Сложност:**
- $O(1)$: вмъкване в края, премахване от началото, достъпване на първия елемент

##### `std::priority_queue`

**Подходящ:**
- "First-in First-out" действия, на които може да се променя приоритета

**Сложност:**
- $O(1)$: достъпване на елемента с най-висок приоритет
- $O(log(n))$: вмъкване на елемент, премахване на елемент


## Лекция №2

### Оценка и сложност на алгоритми

Три главни свойства на компютърен алгоритъм:
- простота и елегантност;
- коректност;
- бързодействие.

> [!warning]
> **NP (nondeterministic polynomial time) Complete** задачи не могат да бъдат решени в полиномиално време, но могат да бъдат полиномиално проверена.

#### Размер на входните данни

> Пример 2.
*Да се намери най-големият общ делител на $a$ и $b$*  
В този пример размерът на входните данни се определя от броя на двоичните цифри (битовете) на по-голямото от числата $a$ и $b$.

> Пример 3.  
*Да се намери покриващо дърво на граф.*  
В този случай характеризираме размера на входа с две числа: брой на върховете и брой на ребрата.

#### Асимптотична нотация

Когато се интересуваме от сложността на алгоритъм най-често се интересуваме как ще работи при достатъчно голям размер n на входните данни.    При формалното оценяване на сложността на алгоритмите изследваме поведението им при "достатъчно голямо" ($n \to \infty$).

$O(f)$ **свойства и примери:**

Нотацията $О(f)$ (най-лош случай) е най-често използваната при оценка на сложност на алгоритми и програми.

**По-важни свойства на О(f) (с $\sim$ означаваме принадлежност):**
- [[notes/math/discrete-math/set-theory/Reflexive Relation|рефлексивност]]: $f \sim О(f)$
- [[notes/math/discrete-math/set-theory/Transitive Relation|транзитивност]]: ако $f \sim О(g)$, $g \sim О(h)$, то  $f \sim О(h)$;
- транспонирана симетрия:  ако $f  \sim Omega(g)$, то $g \sim O(f)$ и обратно
- константите могат да бъдат игнорирани: за всяко $k > 0$, $kF \sim О(F)$
- n, повдигнато в по-висока степен, нараства по-бързо: $n^r \sim О(n^s)$, за $0 < r < s$
- нарастването на сума от функции се определя от най-бързо нарастващата от тях: $f + g \sim max(O(f), O(g))$
- ако $f(n)$ е полином от степен $d$, то $f \sim О(n^d)$
- ако $f$ нараства по-бързо от $g$, а $g$ нараства по-бързо от $h$, то следва, че $f$ нараства по-бързо от $h$

Пример:
- елементарна операция - не зависи от размера на обработваните данни - $O(1)$  
- последователност от оператори - определя се от асимтотично най-бавния - $f + g \sim max(O(f),O(g))$
- композиция на оператори - произведение от сложностите - $f(g) \sim O(f*g)$  
- условни оператори - определя се от асимтотично най-бавния между условието и различните случаи;  
- цикли, два вложени цикъла, $p$ вложени цикли - $O(n)$, $O(n^2)$, $O(n^p)$

#### Популярни алгоритми

- Binary Search: $O(log n)$
- Linear Search: $O(n)$
- Quick Sort: $O(n * log n)$
- Selection Sort: $O(n^2)$
- Travelling salesperson : $O(n!)$
- бързо сортиране на Хоор - $O(n log n)$

**"Разделяй и владей"**:

* Принципи на "разделяй и владей": разбиване на изходната задача на няколко подзадачи (разделяй), решаване на подзадачите и конструиране на решение на изходната задача (владей).
* пример: двоично търсене
* Бързо сортиране с разделяне на дялове (Хоор, "разделяй и владей") - O(n2) в най-лошия случай, O(n) в най-добрия случай, O(n log n) средно. Сложността зависи от избора на елемент за разделяне на дялове;
* Сортиране чрез сливане

**Мажорант**:
_Ще казваме, че даден елемент на множеството е негов мажорант, ако се среща строго повече от $n/2$ пъти._

*Решение с двоен цикъл: *броене колко пъти се среща всеки елемент - $O(n^2)$.

*Решение със сортиране при линейна наредба на елементите му: *сортираме и проверяваме средния елемент за мажорант - време $O(n log n)$ или по-добро, ако сортираме с по-бърз алгоритъм.

*Решение с броене:* $O(n + k)$, ако в масива има $k$ различни стойности.

**Умножение на числа**:
Класическият алгоритъм за умножение на цели числа има сложност $O(n^2)$.

Алгоритъм за умножение на две $n$-цифрени числа $X$ и $Y$, като $n$ е степен на 2. Сложността на алгоритъма е O(n^r), $r = log_2(3)$. Тъй като $log_2(3)$ < 2, то този алгоритъм е по-добър от класическия.

**Циклично преместване на елементите на масив**:

Пример за циклично преместване на $k$ позиции елементите на масив m от n елемента.
$n = 6, k = 2$
0 1 2 3 4 5   ->  2 3 4 5 0 1

Алгоритъм 1:
- копираме първите k елемента на m в друг масив x;
- преместваме n-k елемента на m на k позиции вляво;
- копираме елементите на x обратно в m на последните k позиции.

Сложност $O(n)$, допълнителна памет k елемента. 



## Лекция №3

- [[notes/math/discrete-math/number-theory/Fibonacci Sequence|Fibonacci Sequence]]
- [[notes/math/discrete-math/number-theory/Euclidean Algorithm|Euclidean Algorithm]]
- [[notes/math/discrete-math/number-theory/Factorial|Factorial]]

## Лекция №4

- [[notes/math/discrete-math/number-theory/Prime numbers|Prime numbers]]
- [[notes/math/discrete-math/number-theory/Sieve of Eratosthenes|Sieve of Eratosthenes]]
- [[notes/math/discrete-math/number-theory/Perfect Numbers|Perfect Numbers]]

### Комбинаторни алгоритми

Пермутации: 
- с повторения: Общ брой $n!/(s_1!s_2!...s_k!)$ където $s_i!$ е броят на i-тия различен елемент, участващ в мултимножеството (пример: множество { 1 1 2 3 },  $4!/2!1!1!$)
- без повторения: $n!$, $n$ брой на елементи в множеството

Вариации:
- с повторения: $n = 3, \{ 1 2 3 \},  k = 2$, общ брой: $n^k$
- без повторения: $n = 3, \{ 1 2 3 \},  k = 2$, общ брой: $n!/(n - k)!$ 

Комбинации:
- с повторения: $n = 5, \{ 1 2 3 4 5 \},  k = 2$
$$
\frac{(n + k - 1)!}{(n - 1)! k!}
$$
- без повторения:  $n = 5, \{ 1 2 3 4 5 \},  k = 2$
$$
\frac{n!}{(n - k)!k!}
$$

## Лекция №8

### Динамично оптимиране

## Тест

**Верни твърдения:**
- пряка селекция - $O(n^2)$
- 12 21 е пермутация без повторения за $n = 2$
- Алгоритъм със сложност $O(n^2)$ е по-бавен от друг със сложност $O(1)$
- Метод "разделяй и владей": Разбиване на изходната задача на няколко подзадачи, решаване на подзадачите и конструиране на решение на изходната задача.
- Метод "разделяй и владей" не се реализира само с нерекурсивни функции.
- Биномни коефициенти се пресмятат с приложение на динамично оптимиране.
- Динамично оптимиране не изисква реализация с рекурсивна функция.
- $k$-тият по големина елемент в несортиран масив може да се намери (в най-лошия случай) за време: $O(n^2)$
- Алгоритъм за умножение на две n-цифрени числа може да има сложност: $O(n^2)$
- Контейнерът `map` съхранява двойки елементи (ключ, стойност) и поддържа операция индекс.
- Всяка задача с полиномиален алгоритъм за решаването й е полиномиално проверима.
- $4n + 1$ е $O(n)$
- $5n + n^2$ не е $O(n)$

----

**Въпроси:**

Дадена е следната рекурсивна функция:
```cpp
unsigned no_gcd(unsigned a, unsigned b)
{ return (0 == b) ? a : no_gcd(b, a/b); }
```

Параметри на функция: 100, 50 
Върната стойност: 25

------

Дадена задача има размер на входа n. Разполагаме с два различни алгоритъма $A$ и $B$ за решаването й, изискващи време $an$ и $bn^2$ съответно, където $a$ и $b$ са неизвестни положителни константи. Направено е измерване на времето на работа на всеки от алгоритмите при стойности на $n = 1024$ и $2048$, при което са получени следните резултати: за алгоритъм $A - 128$ и $256$; за алгоритъм $B - 16$ и $64$. 
*Отговор: *Алгоритъм $А$ ще бъде по-бавен от $B$ за стойности на $n$, по-малки от 5.

-----

Дадена е задача за раницата с 4 вида предмети с тегла 2, 4, 1 и 5 и цени съответно 8, 15, 3 и 21. Предполагаме, че има неограничени количества от всички предмети. Решения ли са следните комбинации на зададено максимално тегло - получена максимална цена?
*Отговор*: 12, 50

---
Нека $d(n)$, $e(n)$, $f(n)$ и $g(n)$ са функции с положителни цели аргументи и положителни стойности. 
Вярно твърдение: Ако $d(n)$ е $O(f(n))$, то $a + d(n)$ е $O(f(n))$ за всяка константа $a$.
