<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>algorithms on</title><link>https://garden.itodorova.dev/tags/algorithms/</link><description>Recent content in algorithms on</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://garden.itodorova.dev/tags/algorithms/index.xml" rel="self" type="application/rss+xml"/><item><title>Homework No. 1</title><link>https://garden.itodorova.dev/notes/computer-science/algorithms/Homeworks/Semester-2-Homework-No.-1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://garden.itodorova.dev/notes/computer-science/algorithms/Homeworks/Semester-2-Homework-No.-1/</guid><description>Алгоритъм Алгоритъмът е такова крайно, дискретно (постъпково), детерминирано преобразование, което, приложено над произволен допустим набор от стойности на входното множество, довежда до получаването на единствен набор от допустими стойности на изходното множество.</description></item><item><title>Homework No. 2</title><link>https://garden.itodorova.dev/notes/computer-science/algorithms/Homeworks/Semester-2-Homework-No.-2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://garden.itodorova.dev/notes/computer-science/algorithms/Homeworks/Semester-2-Homework-No.-2/</guid><description>Алгоритъм на Евклид без цикъл 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include &amp;lt;iostream&amp;gt; int main() { int a = 120; int b = 60; label: int reminder = a % b; if (reminder &amp;gt; 0) { a = b; b = reminder; goto label; } std::cout &amp;lt;&amp;lt; b; } Резултат:</description></item><item><title>Leibniz formula for π (pi)</title><link>https://garden.itodorova.dev/notes/computer-science/algorithms/Leibniz-formula-for-%CF%80-pi/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://garden.itodorova.dev/notes/computer-science/algorithms/Leibniz-formula-for-%CF%80-pi/</guid><description>$$ \frac{\pi}{4} = \frac{1}{1}
\frac{1}{3} \frac{1}{5} \frac{1}{7} \frac{1}{9} - \dots = \sum_{i = 1}^{\infty}{(-1)^{i+1}}\frac{1}{2i-1} $$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include &amp;lt;cmath&amp;gt; int main() { float a = 1.</description></item><item><title>Maclaurin Expansion of sin(x)</title><link>https://garden.itodorova.dev/notes/computer-science/algorithms/Maclaurin-Expansion-of-sinx/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://garden.itodorova.dev/notes/computer-science/algorithms/Maclaurin-Expansion-of-sinx/</guid><description>$$ sin(x) = \frac{x}{1!}
\frac{x^3}{3!} \frac{x^5}{5!} \frac{x^7}{7!} \frac{x^9}{9!} &amp;hellip; = \sum_{i = 1}^{\infty}{(-1)^{i + 1}}\frac{{x^{(2i-1)}}}{(2i-1)!</description></item><item><title>Претърсване</title><link>https://garden.itodorova.dev/notes/computer-science/algorithms/%D0%9F%D1%80%D0%B5%D1%82%D1%8A%D1%80%D1%81%D0%B2%D0%B0%D0%BD%D0%B5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://garden.itodorova.dev/notes/computer-science/algorithms/%D0%9F%D1%80%D0%B5%D1%82%D1%8A%D1%80%D1%81%D0%B2%D0%B0%D0%BD%D0%B5/</guid><description>Претърсване чрез обхождане Time complexity: $O(n)$
Обхожда се целия масив и се търси елемента.
1 2 3 4 5 6 7 8 9 bool search_all(const int *arr, unsigned n, int x) { bool isFound = false; for (int i = 0; i &amp;lt; n; ++i) { if (x == arr[i]) { isFound = true; } } return isFound; } &amp;ldquo;Докато намериш с &amp;lsquo;котва&amp;rsquo;&amp;rdquo; Търси се, докато елемента не се намери, като преди това търсения елемент се добавя в края на масива.</description></item><item><title>Сортиране</title><link>https://garden.itodorova.dev/notes/computer-science/algorithms/%D0%A1%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%B0%D0%BD%D0%B5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://garden.itodorova.dev/notes/computer-science/algorithms/%D0%A1%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%B0%D0%BD%D0%B5/</guid><description>Сортиране в друг масив 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 int main() { int a[] = {2, 8, 4, 0, 6, 9, 1, 4, 7}; int n = sizeof(a) / sizeof(int); int b[n]; int max = a[0]; for (int i = 1; i &amp;lt; n; i++) { if (a[i] &amp;gt; max) { max = a[i]; } } b[n - 1] = max; for (int i = 0; i &amp;lt; n - 1; i++) { int min = a[0]; int flag = 0; for (int j = 1; j &amp;lt; n; j++) { if (min &amp;gt; a[j]) { min = a[j]; flag = j; } } b[i] = min; a[flag] = max; } return 0; } Сортиране с пряка селекция / Selection sort 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 int main() { int a[] = {3, 4, 9, 0, 4, 8}; int n = sizeof(a) / sizeof(int); for (int i = 0; i &amp;lt; n - 1; i++) { int min = a[i]; int flag = i; for (int j = i + 1; j &amp;lt; n; j++) { if (a[j] &amp;lt; min) { min = a[j]; flag = j; } } a[flag] = a[i]; a[i] = min; } }</description></item></channel></rss>